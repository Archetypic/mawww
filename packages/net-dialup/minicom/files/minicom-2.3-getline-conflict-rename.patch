Source: https://alioth.debian.org/scm/viewvc.php/minicom/src/minicom.c?view=markup&revision=1.36&root=minicom
Upstream: yes
Reason: rename getline -> mc_getline because of autoconf changes (with 2.62)

This patch can be removed with next release (2.4), as it will be included in source.

--- src/minicom.c   2008/08/02 22:09:35     1.35
+++ src/minicom.c   2008/08/05 07:08:45     1.36
@@ -164,7 +164,7 @@
 #endif /*SIGTSTP*/

 /* Get a line from either window or scroll back buffer. */
-static ELM *getline(WIN *w, int no)
+static ELM *mc_getline(WIN *w, int no)
 {
   int i;
   static ELM outofrange[MAXCOLS] = {{0,0,0}};
@@ -202,7 +202,7 @@

   w->direct = 0;
   for (f = 0; f < w->ys; f++)
-    mc_wdrawelm(w, f, getline(w, y++));
+    mc_wdrawelm(w, f, mc_getline(w, y++));
   if (r)
     mc_wredraw(w, 1);
   w->direct = 1;
@@ -224,7 +224,7 @@
   tmp_line[0]='\0';
   w->direct = 0;
   for (f = 0; f < w->ys; f++) {
-    tmp_e = getline(w, y++);
+    tmp_e = mc_getline(w, y++);

     /* First we "accumulate" the line into a variable */
     mc_wdrawelm_var(w, tmp_e, tmp_line);
@@ -321,7 +321,7 @@

   for (next_line = hit_line; next_line <= all_lines; next_line++) {
     /* we do 'something' here... :-) */
-    tmp_e = getline(w_hist, next_line);
+    tmp_e = mc_getline(w_hist, next_line);

     /*
      * First we "accumulate" the line into a variable.
@@ -376,9 +376,9 @@
 static void drawcite(WIN *w, int y, int citey, int start, int end)
 {
   if (y+citey >= start && y+citey <= end)
-    mc_wdrawelm_inverse(w, y, getline(w, y+citey));
+    mc_wdrawelm_inverse(w, y, mc_getline(w, y+citey));
   else
-    mc_wdrawelm(w, y, getline(w, y+citey));
+    mc_wdrawelm(w, y, mc_getline(w, y+citey));
 }

 static void drawcite_whole(WIN *w, int y, int start, int end)
@@ -397,7 +397,7 @@
   for (y=start; y<=end; y++) {
     vt_send('>');
     vt_send(' ');
-    tmp_e = getline(w, y);
+    tmp_e = mc_getline(w, y);
     mc_wdrawelm_var(w, tmp_e, tmp_line);
     tmp_line[w->xs] = 0;
     for (x = w->xs-1; x >= 0; x--) {
@@ -597,7 +597,7 @@
         if (citemode) {
           inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
         } else {
-          tmp_e = getline(b_us, y);
+          tmp_e = mc_getline(b_us, y);
           if (wcslen(look_for) > 1) {
             /* quick scan for pattern match */
             mc_wdrawelm_var(b_us, tmp_e, tmp_line);
@@ -608,9 +608,9 @@
         }

         if (inverse)
-          mc_wdrawelm_inverse(b_us, 0, getline(b_us, y));
+          mc_wdrawelm_inverse(b_us, 0, mc_getline(b_us, y));
         else
-          mc_wdrawelm(b_us, 0, getline(b_us, y));
+          mc_wdrawelm(b_us, 0, mc_getline(b_us, y));
         if (citemode)
           mc_wlocate(b_us, 0, cite_y);
         mc_wflush();
@@ -645,7 +645,7 @@
         if (citemode) {
           inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
         } else {
-          tmp_e = getline(b_us, y + b_us->ys - 1);
+          tmp_e = mc_getline(b_us, y + b_us->ys - 1);
           if (wcslen(look_for) > 1) {
             /* quick scan for pattern match */
             mc_wdrawelm_var(b_us, tmp_e, tmp_line);
@@ -657,10 +657,10 @@

         if (inverse)
           mc_wdrawelm_inverse(b_us, b_us->ys - 1,
-                           getline(b_us, y + b_us->ys - 1));
+                           mc_getline(b_us, y + b_us->ys - 1));
         else
           mc_wdrawelm(b_us, b_us->ys - 1,
-                   getline(b_us, y + b_us->ys - 1));
+                   mc_getline(b_us, y + b_us->ys - 1));
         if (citemode)
           mc_wlocate(b_us, 0, cite_y);
         mc_wflush();
@@ -750,7 +750,7 @@
         mc_wlocate(b_st, 0, 0);
         mc_wprintf(b_st, hline);
         mc_wredraw(b_st, 1);
-        mc_wdrawelm_inverse(b_us, cite_y, getline(b_us, cite_ystart));
+        mc_wdrawelm_inverse(b_us, cite_y, mc_getline(b_us, cite_ystart));
         mc_wlocate(b_us, 0, cite_y);
         break;
       case K_ESC:
